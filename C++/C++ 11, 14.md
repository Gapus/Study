# auto
> 선언된 변수 또는 람다 식 매개 변수의 초기화 식을 사용하여 해당형식을 컴파일 타임에 
추측하도록 한다.

```C
map<int,list<string>>::iterator i = m.begin();   
auto i = m.begin(); 
```

# pair
> 두 자료형을 묶을 수 있다.
```C
#include <utility>
using namespace std;
int main(void){
    
    //일반적 선언
    pair<int, int> pair1;       

    //make_pair를 이용해 생성할수있다.
    pair1 = make_pair(10, 20);  
 
    // 초기화 생성이 가능하다.
    pair<int, int> pair2(30,40); 

    //중복 사용이 허용된다.
    pair<pair<int, int>, pair<double, double>> pair3;
}
```
# tuple
> pair의 확장 2개이상의 _NMAX 만큼 타입인자를 받을수 있다.  (vs2010경우 20개)

```C
#include <tuple>
 
using namespace std;
 
typedef tuple<int, double, string> ids;
typedef std::tuple<int, double, int, double> Mytuple;

int main()
{
   // 생성자, tuple 초기화
   ids p1(10, 1.1f, "SooKkaRak");
 
   // 복사 생성
   ids p2(p1);

   Mytuple c0;
   //make_tuple를 이용한 생성 (call-by-value)
   c0 = make_tuple(4, 5.f, 6, 7.f);

   int v4 = 4;
   double v5 = 5;
   int v6 = 6;
 
   // 각 타입 인자들이 참조로 반환되기에, v4~v7의 값이 변경된다. (call-by-reference)
   tie(v4, v5, v6, ignore) = c0;  

   //ignore 빈구조체, 아무런 동작을 않하기 위해 정의되어있다.

    cout << " " << get<0>(c0);
    cout << " " << get<1>(c0);
    cout << " " << get<2>(c0);
    cout << " " << get<3>(c0);
    //get을 이용해 인자의 값을 바로 꺼내올수있다.

    if(tie(totalScore, killCount, assistCount) > tie(other.totalScore, other.killCount, other.assistCount)) {
        //사전식 비교기능, 첫번째 인자부터 순차 비교하게 되어있다.
    }       
}
```


# range based for

> 길이 기반 순회, 배열과 STL에 대응한다.

```C
for ( for-range-declaration : expression )
        statement

using namespace std;
 
void main()
{
    vector<int> temp = {1, 2, 3, 4, 5};
    for (auto i in temp)
        cout << i;
}
```

> 클래스에 begin()과 end()을 제공하고 Iterator에 operator++, operator*, operator!= 구현하면 사용할수있다.

# non-static data member initializers
```c
Class TEST 
{   //멤버변수의 선언 초기화를 말한다.
public: 
    int n1 = 100; 
    std::string s1 = "test";
};
```
# 생성 초기화
```C
Test test {1, "test"};
//클래스의 public멤버의 생성 초기화 기능이다.
```

# initializer lists

> 생성초기화를 배열과 STL에 적용한것을 말한다.

```C
template <class T> 
class vector
{ 
    public: vector(std::initializer_list<T>); 
}; 
std::vector<int> v { 1, 2, 3 };

int sum ( initializer_list<int> li ) 
{ 
    return accumulate(li.begin(), li.end(), 0); 
} 
auto result = sum ({9, 8, 7, 6});
```

# constexpr
>  일반화된 상수 표현식(Generalized constant expression)을 사용할 수 있게 해주며, 일반화된 상수 표현식을 통해 변수나 함수, 생성자 함수에 대하여 컴파일 타임에 평가될 수 있도록 처리해 줄 수 있다.
 
> const와 constexpr의 주요 차이점은 const 변수의 초기화를 런타임까지 지연시킬 수 있는 반면, constexpr 변수는 반드시 컴파일 타임에 초기화가 되어 있어야 한다.

> 가상으로 재정의된 함수가 아니어야 한다.
반환값의 타입은 반드시 LiteralType이어야 한다.

> 함수에 constexpr을 붙일 경우 inline을 암시한다.
즉, 컴파일 타임에 평가하기 때문이며, inline 함수들과 같이 컴파일된다.

> constexpr 함수는 컴파일러에게 가능하다면, 상수시간에 컴파일해 달라고 요청하는 것이지만 상황에 따라 컴파일 타임에 미리 실행될 수도 있고, 그렇지 못하고 런타임에 실행될 수도 있다.

# Lambda
> 이름없는 함수
```c
[](float a, float b) {  
    return (std::abs(a) < std::abs(b));  
}
```

1 | 2 | 3 | 4 | 5 | 6
--|--|--|--|--|--
[=] | () | mutable | throw() | -> int | {}

1. 캡처절 : 바깥쪽 변수 엑세스 하거나 캡처
1. 매개변수 목록 
1. mutable specification : mutable지정으로 캡처 변수 수정가능
1. exception-specification : 예외 형 지정
1. trailing-return-type : 리턴형 지정
1. 람다 몸체

# capture

> 빈 캡처 절인 [ ]는 람다 식의 본문이 바깥쪽 범위의 변수에 액세스하지 않음을 나타냅니다.
기본 캡처 모드(표준 구문에서는 capture-default)를 사용하여 람다에서 참조되는 외부 변수를 캡처하는 방법을 나타낼 수 있습니다. [&]는 참조하는 모든 변수가 참조를 기준으로 캡처된다는 것을 의미하고 [=]는 값을 기준으로 캡처된다는 것을 의미합니다. 기본 캡처 모드를 사용하고 특정 변수에 대해서는 반대 모드를 지정할 수 있습니다. 예를 들어, 람다 본문이 외부 변수 total에 참조별로 액세스하고 외부 변수 factor에 값별로 액세스하는 경우 다음 캡처 절이 동일합니다.

```C
[&total, factor]  
[factor, &total]  
[&, factor]  
[factor, &]  
[=, &total]  
[&total, =]  

struct S { void f(int i); };  
  
void S::f(int i) {  
    [&, i]{};    // OK  
    [&, &i]{};   // ERROR: i preceded by & when & is the default  
    [=, this]{}; // ERROR: this when = is the default  
    [i, i]{};    // ERROR: i repeated  
}  
```

# generic lambdas
> C++14 부터 매개변수에 auto를 사용할수 있다 이로인해 매개변수 추론이 가능하다.
```C
auto Add = [] (auto a, auto b) /*-> decltype(a + b)*/ { return a + b; };
 
iResult = Add(2, 4);
fResult = Add(2.f, 4.f);
```
# nullptr

> null포인터 keyword 기존의 NULL은 정의가 0L이기 때문에 태생적으로 생기던 이슈를 해결할수 있게 되었다.

# unique_ptr

# shared_ptr
> 참조 카운팅 포인터로 할당된 자원의 자동적 해제를 위해 만들어졌다.

```C
//여러가지 생성법
auto sp1 = make_shared<Song>(L"The Beatles", L"Im Happy Just to Dance With You");
shared_ptr<Song> sp2(new Song(L"Lady Gaga", L"Just Dance"));
shared_ptr<Song> sp5(nullptr);
sp5 = make_shared<Song>(L"Elton John", L"I'm Still Standing");

//이미 생성된 객체의 소유권의 공유법
auto sp3(sp2);
auto sp4 = sp2;
shared_ptr<Song> sp7(nullptr);
sp1.swap(sp2);

//STL에서의 사용
vector<shared_ptr<Song>> v;

v.push_back(make_shared<Song>(L"Bob Dylan", L"The Times They Are A Changing"));
v.push_back(make_shared<Song>(L"Aretha Franklin", L"Bridge Over Troubled Water"));
v.push_back(make_shared<Song>(L"Thal�a", L"Entre El Mar y Una Estrella"));

vector<shared_ptr<Song>> v2;
remove_copy_if(v.begin(), v.end(), back_inserter(v2), [] (shared_ptr<Song> s) 
{
    return s->artist.compare(L"Bob Dylan") == 0;		
});

for (const auto& s : v2)
{
    wcout << s->artist << L":" << s->title << endl;
}

```
# weak_ptr

# auto_ptr

# array

# forward_list

# std::move
> 객체에 대한 universal reference를 취해서 해당 오브젝트에 대한 rvalue reference를 돌려준다.

# std::forward
> 인자가 rvalue로 초기화되었을 때에만 rvalue로 캐스팅해준다.

# chrono
> 시간관련

# atomic
> 정수형 또는 포인터 타입에 대해 산술 연산들을 atomic하게 수행할 수 있도록 해 주는 템플릿 클래스이다.
(더하고 빼고, 그리고 and/or/xor 등의 비트 연산들...)

# thread_local
> 저장소 클래스 지정자는 클래스 멤버 및 개체에 대한 스레드 로컬 저장소를 지정하는 데 권장되는 방법입니다. 

# async/future

