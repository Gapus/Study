
# 연산자 오버로드

> 클래스 단위로 연산자를 재정의 하는 기능

> 타입 예약어 연산자 (파라미터 리스트)
```
type operator operator-symbol ( parameter-list )
```

```C
class Point  
{  
public:  
    Point operator<( Point & );
    friend Point operator+( Point&, int );  
    friend Point operator+( int, Point& );  
};  
```
> 오버로드된 연산자는 비정적 클래스 멤버 함수 또는 전역 함수여야 합니다. 

> private 또는 protected 클래스 멤버에 액세스해야 하는 전역 함수는 해당 클래스의 friend로 선언해야 합니다. 

> 전역 함수는 클래스 또는 열거형 형식이거나 클래스 또는 열거형 형식에 대한 참조인 인수를 하나 이상 사용해야 합니다.

> 연산자는 기본 제공 형식과 함께 연산자를 사용하는 일반적인 경우에 적용되는 피연산자의 수, 우선 순위 및 그룹화를 준수합니다. 

> 따라서 x 좌표에 2를 더하고 y 좌표에 3을 더할 것을 기대하고 "Point 형식의 개체에 2와 3 더하기"라는 개념을 표현하는 방법은 없습니다.

> 멤버 함수로 선언된 단항 연산자는 인수를 사용하지 않습니다. 전역 함수로 선언된 경우 인수를 한 개 사용합니다.

> 멤버 함수로 선언된 이항 연산자는 인수를 한 개 사용합니다. 전역 함수로 선언된 경우 인수를 두 개 사용합니다.

> 연산자를 단항 또는 이항 연산자(&, *, + 및 -)로 사용할 수 있으면 각 사용을 별도로 오버로드할 수 있습니다.

> 오버로드된 연산자는 기본 인수를 사용할 수 없습니다.

> 할당(operator=)을 제외한 모든 오버로드된 연산자는 파생 클래스에서 상속합니다.

> 멤버 함수 오버로드된 연산자의 첫 번째 인수는 항상 연산자가 호출되는 개체의 클래스 형식입니다(연산자가 선언된 클래스 또는 해당 클래스에서 파생된 클래스). 첫 번째 인수에 대한 변환은 제공되지 않습니다.

# 오버로드 가능 연산자.

연산자 |	이름|	형식
--|--|--
,	|쉼표	|이항
!	|논리 NOT	|단항
!=	|같지 않음	|이항
%	|모듈러스	|이항
%=	|모듈러스 대입	|이항
&	|비트 AND	|이항
&	|Address-of	|단항
&&	|논리적 AND	|이항
&=	|비트 AND 대입	|이항
( )	|함수 호출	|—
( )	|캐스트 연산자	|단항
*	|곱하기	이항
*	|포인터 역참조	|단항
*=	|곱하기 할당	|이항
+	|더하기	|이항
+	|단항 더하기	|단항
++	|증가 1	|단항
+=	|더하기 할당	|이항
–	|빼기	|이항
–	|단항 부정 연산자	|단항
––	|감소 1	|단항
–=	|빼기 할당|	이항
–>	|멤버 선택	|이항
–>*	|멤버 포인터 선택	|이항
/	|나눗셈 기호	|이항
/=	|나누기 할당	|이항
<	|보다 작음	|이항
<<	|왼쪽 <Shift>	|이항
<<=	|왼쪽 시프트 할당	|이항
<=	|작거나 같음|	이항
=	|할당	|이항
==	|같음	|이항
>	|보다 큼	|이항
>=	|크거나 같음	|이항
>>	|오른쪽 Shift	|이항
>>=	|오른쪽 시프트 할당	|이항
[ ]	|배열 첨자	|—
^	|배타적 OR	|이항
^=	|배타적 OR 할당	|이항
&#124;	|포괄적 비트 OR	|이항
&#124;=	|포괄적 비트 OR 대입	|이항
&#124;&#124;|	논리적 OR	|이항
~	|1의 보수	|단항
delete|	Delete	|—
new	|New	|—
conversion operators |	conversion operators	|단항